{"ast":null,"code":"function _toConsumableArray(arr) {\n  return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\n\nfunction _nonIterableSpread() {\n  throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _iterableToArray(iter) {\n  if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter);\n}\n\nfunction _arrayWithoutHoles(arr) {\n  if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\n\nfunction _slicedToArray(arr, i) {\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\n\nfunction _nonIterableRest() {\n  throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\n\nfunction _unsupportedIterableToArray(o, minLen) {\n  if (!o) return;\n  if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n  var n = Object.prototype.toString.call(o).slice(8, -1);\n  if (n === \"Object\" && o.constructor) n = o.constructor.name;\n  if (n === \"Map\" || n === \"Set\") return Array.from(o);\n  if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\n\nfunction _arrayLikeToArray(arr, len) {\n  if (len == null || len > arr.length) len = arr.length;\n\n  for (var i = 0, arr2 = new Array(len); i < len; i++) {\n    arr2[i] = arr[i];\n  }\n\n  return arr2;\n}\n\nfunction _iterableToArrayLimit(arr, i) {\n  if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return;\n  var _arr = [];\n  var _n = true;\n  var _d = false;\n  var _e = undefined;\n\n  try {\n    for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n      _arr.push(_s.value);\n\n      if (i && _arr.length === i) break;\n    }\n  } catch (err) {\n    _d = true;\n    _e = err;\n  } finally {\n    try {\n      if (!_n && _i[\"return\"] != null) _i[\"return\"]();\n    } finally {\n      if (_d) throw _e;\n    }\n  }\n\n  return _arr;\n}\n\nfunction _arrayWithHoles(arr) {\n  if (Array.isArray(arr)) return arr;\n}\n/**\n * @fileOverview calculate tick values of scale\n * @author xile611, arcthur\n * @date 2015-09-17\n */\n\n\nimport Decimal from 'decimal.js-light';\nimport { compose, range, memoize, map, reverse } from './util/utils';\nimport Arithmetic from './util/arithmetic';\n/**\n * Calculate a interval of a minimum value and a maximum value\n *\n * @param  {Number} min       The minimum value\n * @param  {Number} max       The maximum value\n * @return {Array} An interval\n */\n\nfunction getValidInterval(_ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n      min = _ref2[0],\n      max = _ref2[1];\n\n  var validMin = min,\n      validMax = max; // exchange\n\n  if (min > max) {\n    validMin = max;\n    validMax = min;\n  }\n\n  return [validMin, validMax];\n}\n/**\n * Calculate the step which is easy to understand between ticks, like 10, 20, 25\n *\n * @param  {Decimal} roughStep        The rough step calculated by deviding the\n * difference by the tickCount\n * @param  {Boolean} allowDecimals    Allow the ticks to be decimals or not\n * @param  {Integer} correctionFactor A correction factor\n * @return {Decimal} The step which is easy to understand between two ticks\n */\n\n\nfunction getFormatStep(roughStep, allowDecimals, correctionFactor) {\n  if (roughStep.lte(0)) {\n    return new Decimal(0);\n  }\n\n  var digitCount = Arithmetic.getDigitCount(roughStep.toNumber()); // The ratio between the rough step and the smallest number which has a bigger\n  // order of magnitudes than the rough step\n\n  var digitCountValue = new Decimal(10).pow(digitCount);\n  var stepRatio = roughStep.div(digitCountValue); // When an integer and a float multiplied, the accuracy of result may be wrong\n\n  var stepRatioScale = digitCount !== 1 ? 0.05 : 0.1;\n  var amendStepRatio = new Decimal(Math.ceil(stepRatio.div(stepRatioScale).toNumber())).add(correctionFactor).mul(stepRatioScale);\n  var formatStep = amendStepRatio.mul(digitCountValue);\n  return allowDecimals ? formatStep : new Decimal(Math.ceil(formatStep));\n}\n/**\n * calculate the ticks when the minimum value equals to the maximum value\n *\n * @param  {Number}  value         The minimum valuue which is also the maximum value\n * @param  {Integer} tickCount     The count of ticks\n * @param  {Boolean} allowDecimals Allow the ticks to be decimals or not\n * @return {Array}                 ticks\n */\n\n\nfunction getTickOfSingleValue(value, tickCount, allowDecimals) {\n  var step = 1; // calculate the middle value of ticks\n\n  var middle = new Decimal(value);\n\n  if (!middle.isint() && allowDecimals) {\n    var absVal = Math.abs(value);\n\n    if (absVal < 1) {\n      // The step should be a float number when the difference is smaller than 1\n      step = new Decimal(10).pow(Arithmetic.getDigitCount(value) - 1);\n      middle = new Decimal(Math.floor(middle.div(step).toNumber())).mul(step);\n    } else if (absVal > 1) {\n      // Return the maximum integer which is smaller than 'value' when 'value' is greater than 1\n      middle = new Decimal(Math.floor(value));\n    }\n  } else if (value === 0) {\n    middle = new Decimal(Math.floor((tickCount - 1) / 2));\n  } else if (!allowDecimals) {\n    middle = new Decimal(Math.floor(value));\n  }\n\n  var middleIndex = Math.floor((tickCount - 1) / 2);\n  var fn = compose(map(function (n) {\n    return middle.add(new Decimal(n - middleIndex).mul(step)).toNumber();\n  }), range);\n  return fn(0, tickCount);\n}\n/**\n * Calculate the step\n *\n * @param  {Number}  min              The minimum value of an interval\n * @param  {Number}  max              The maximum value of an interval\n * @param  {Integer} tickCount        The count of ticks\n * @param  {Boolean} allowDecimals    Allow the ticks to be decimals or not\n * @param  {Number}  correctionFactor A correction factor\n * @return {Object}  The step, minimum value of ticks, maximum value of ticks\n */\n\n\nfunction calculateStep(min, max, tickCount, allowDecimals) {\n  var correctionFactor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0; // dirty hack (for recharts' test)\n\n  if (!Number.isFinite((max - min) / (tickCount - 1))) {\n    return {\n      step: new Decimal(0),\n      tickMin: new Decimal(0),\n      tickMax: new Decimal(0)\n    };\n  } // The step which is easy to understand between two ticks\n\n\n  var step = getFormatStep(new Decimal(max).sub(min).div(tickCount - 1), allowDecimals, correctionFactor); // A medial value of ticks\n\n  var middle; // When 0 is inside the interval, 0 should be a tick\n\n  if (min <= 0 && max >= 0) {\n    middle = new Decimal(0);\n  } else {\n    // calculate the middle value\n    middle = new Decimal(min).add(max).div(2); // minus modulo value\n\n    middle = middle.sub(new Decimal(middle).mod(step));\n  }\n\n  var belowCount = Math.ceil(middle.sub(min).div(step).toNumber());\n  var upCount = Math.ceil(new Decimal(max).sub(middle).div(step).toNumber());\n  var scaleCount = belowCount + upCount + 1;\n\n  if (scaleCount > tickCount) {\n    // When more ticks need to cover the interval, step should be bigger.\n    return calculateStep(min, max, tickCount, allowDecimals, correctionFactor + 1);\n  }\n\n  if (scaleCount < tickCount) {\n    // When less ticks can cover the interval, we should add some additional ticks\n    upCount = max > 0 ? upCount + (tickCount - scaleCount) : upCount;\n    belowCount = max > 0 ? belowCount : belowCount + (tickCount - scaleCount);\n  }\n\n  return {\n    step: step,\n    tickMin: middle.sub(new Decimal(belowCount).mul(step)),\n    tickMax: middle.add(new Decimal(upCount).mul(step))\n  };\n}\n/**\n * Calculate the ticks of an interval, the count of ticks will be guraranteed\n *\n * @param  {Number}  min, max      min: The minimum value, max: The maximum value\n * @param  {Integer} tickCount     The count of ticks\n * @param  {Boolean} allowDecimals Allow the ticks to be decimals or not\n * @return {Array}   ticks\n */\n\n\nfunction getNiceTickValuesFn(_ref3) {\n  var _ref4 = _slicedToArray(_ref3, 2),\n      min = _ref4[0],\n      max = _ref4[1];\n\n  var tickCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true; // More than two ticks should be return\n\n  var count = Math.max(tickCount, 2);\n\n  var _getValidInterval = getValidInterval([min, max]),\n      _getValidInterval2 = _slicedToArray(_getValidInterval, 2),\n      cormin = _getValidInterval2[0],\n      cormax = _getValidInterval2[1];\n\n  if (cormin === -Infinity || cormax === Infinity) {\n    var _values = cormax === Infinity ? [cormin].concat(_toConsumableArray(range(0, tickCount - 1).map(function () {\n      return Infinity;\n    }))) : [].concat(_toConsumableArray(range(0, tickCount - 1).map(function () {\n      return -Infinity;\n    })), [cormax]);\n\n    return min > max ? reverse(_values) : _values;\n  }\n\n  if (cormin === cormax) {\n    return getTickOfSingleValue(cormin, tickCount, allowDecimals);\n  } // Get the step between two ticks\n\n\n  var _calculateStep = calculateStep(cormin, cormax, count, allowDecimals),\n      step = _calculateStep.step,\n      tickMin = _calculateStep.tickMin,\n      tickMax = _calculateStep.tickMax;\n\n  var values = Arithmetic.rangeStep(tickMin, tickMax.add(new Decimal(0.1).mul(step)), step);\n  return min > max ? reverse(values) : values;\n}\n/**\n * Calculate the ticks of an interval, the count of ticks won't be guraranteed\n *\n * @param  {Number}  min, max      min: The minimum value, max: The maximum value\n * @param  {Integer} tickCount     The count of ticks\n * @param  {Boolean} allowDecimals Allow the ticks to be decimals or not\n * @return {Array}   ticks\n */\n\n\nfunction getTickValuesFn(_ref5) {\n  var _ref6 = _slicedToArray(_ref5, 2),\n      min = _ref6[0],\n      max = _ref6[1];\n\n  var tickCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true; // More than two ticks should be return\n\n  var count = Math.max(tickCount, 2);\n\n  var _getValidInterval3 = getValidInterval([min, max]),\n      _getValidInterval4 = _slicedToArray(_getValidInterval3, 2),\n      cormin = _getValidInterval4[0],\n      cormax = _getValidInterval4[1];\n\n  if (cormin === -Infinity || cormax === Infinity) {\n    return [min, max];\n  }\n\n  if (cormin === cormax) {\n    return getTickOfSingleValue(cormin, tickCount, allowDecimals);\n  }\n\n  var step = getFormatStep(new Decimal(cormax).sub(cormin).div(count - 1), allowDecimals, 0);\n  var fn = compose(map(function (n) {\n    return new Decimal(cormin).add(new Decimal(n).mul(step)).toNumber();\n  }), range);\n  var values = fn(0, count).filter(function (entry) {\n    return entry >= cormin && entry <= cormax;\n  });\n  return min > max ? reverse(values) : values;\n}\n/**\n * Calculate the ticks of an interval, the count of ticks won't be guraranteed,\n * but the domain will be guaranteed\n *\n * @param  {Number}  min, max      min: The minimum value, max: The maximum value\n * @param  {Integer} tickCount     The count of ticks\n * @param  {Boolean} allowDecimals Allow the ticks to be decimals or not\n * @return {Array}   ticks\n */\n\n\nfunction getTickValuesFixedDomainFn(_ref7, tickCount) {\n  var _ref8 = _slicedToArray(_ref7, 2),\n      min = _ref8[0],\n      max = _ref8[1];\n\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true; // More than two ticks should be return\n\n  var _getValidInterval5 = getValidInterval([min, max]),\n      _getValidInterval6 = _slicedToArray(_getValidInterval5, 2),\n      cormin = _getValidInterval6[0],\n      cormax = _getValidInterval6[1];\n\n  if (cormin === -Infinity || cormax === Infinity) {\n    return [min, max];\n  }\n\n  if (cormin === cormax) {\n    return [cormin];\n  }\n\n  var count = Math.max(tickCount, 2);\n  var step = getFormatStep(new Decimal(cormax).sub(cormin).div(count - 1), allowDecimals, 0);\n  var values = [].concat(_toConsumableArray(Arithmetic.rangeStep(new Decimal(cormin), new Decimal(cormax).sub(new Decimal(0.99).mul(step)), step)), [cormax]);\n  return min > max ? reverse(values) : values;\n}\n\nexport var getNiceTickValues = memoize(getNiceTickValuesFn);\nexport var getTickValues = memoize(getTickValuesFn);\nexport var getTickValuesFixedDomain = memoize(getTickValuesFixedDomainFn);","map":{"version":3,"names":["_toConsumableArray","arr","_arrayWithoutHoles","_iterableToArray","_unsupportedIterableToArray","_nonIterableSpread","TypeError","iter","Symbol","iterator","Object","Array","from","isArray","_arrayLikeToArray","_slicedToArray","i","_arrayWithHoles","_iterableToArrayLimit","_nonIterableRest","o","minLen","n","prototype","toString","call","slice","constructor","name","test","len","length","arr2","_arr","_n","_d","_e","undefined","_i","_s","next","done","push","value","err","Decimal","compose","range","memoize","map","reverse","Arithmetic","getValidInterval","_ref","_ref2","min","max","validMin","validMax","getFormatStep","roughStep","allowDecimals","correctionFactor","lte","digitCount","getDigitCount","toNumber","digitCountValue","pow","stepRatio","div","stepRatioScale","amendStepRatio","Math","ceil","add","mul","formatStep","getTickOfSingleValue","tickCount","step","middle","isint","absVal","abs","floor","middleIndex","fn","calculateStep","arguments","Number","isFinite","tickMin","tickMax","sub","mod","belowCount","upCount","scaleCount","getNiceTickValuesFn","_ref3","_ref4","count","_getValidInterval","_getValidInterval2","cormin","cormax","Infinity","_values","concat","_calculateStep","values","rangeStep","getTickValuesFn","_ref5","_ref6","_getValidInterval3","_getValidInterval4","filter","entry","getTickValuesFixedDomainFn","_ref7","_ref8","_getValidInterval5","_getValidInterval6","getNiceTickValues","getTickValues","getTickValuesFixedDomain"],"sources":["/home/foglet15/Code/Python/rcwa/rcwa_www/frontend_rcwa/node_modules/recharts-scale/es6/getNiceTickValues.js"],"sourcesContent":["function _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== \"undefined\" && Symbol.iterator in Object(iter)) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\"); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === \"string\") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === \"Object\" && o.constructor) n = o.constructor.name; if (n === \"Map\" || n === \"Set\") return Array.from(o); if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { if (typeof Symbol === \"undefined\" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\"return\"] != null) _i[\"return\"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\n/**\n * @fileOverview calculate tick values of scale\n * @author xile611, arcthur\n * @date 2015-09-17\n */\nimport Decimal from 'decimal.js-light';\nimport { compose, range, memoize, map, reverse } from './util/utils';\nimport Arithmetic from './util/arithmetic';\n/**\n * Calculate a interval of a minimum value and a maximum value\n *\n * @param  {Number} min       The minimum value\n * @param  {Number} max       The maximum value\n * @return {Array} An interval\n */\n\nfunction getValidInterval(_ref) {\n  var _ref2 = _slicedToArray(_ref, 2),\n      min = _ref2[0],\n      max = _ref2[1];\n\n  var validMin = min,\n      validMax = max; // exchange\n\n  if (min > max) {\n    validMin = max;\n    validMax = min;\n  }\n\n  return [validMin, validMax];\n}\n/**\n * Calculate the step which is easy to understand between ticks, like 10, 20, 25\n *\n * @param  {Decimal} roughStep        The rough step calculated by deviding the\n * difference by the tickCount\n * @param  {Boolean} allowDecimals    Allow the ticks to be decimals or not\n * @param  {Integer} correctionFactor A correction factor\n * @return {Decimal} The step which is easy to understand between two ticks\n */\n\n\nfunction getFormatStep(roughStep, allowDecimals, correctionFactor) {\n  if (roughStep.lte(0)) {\n    return new Decimal(0);\n  }\n\n  var digitCount = Arithmetic.getDigitCount(roughStep.toNumber()); // The ratio between the rough step and the smallest number which has a bigger\n  // order of magnitudes than the rough step\n\n  var digitCountValue = new Decimal(10).pow(digitCount);\n  var stepRatio = roughStep.div(digitCountValue); // When an integer and a float multiplied, the accuracy of result may be wrong\n\n  var stepRatioScale = digitCount !== 1 ? 0.05 : 0.1;\n  var amendStepRatio = new Decimal(Math.ceil(stepRatio.div(stepRatioScale).toNumber())).add(correctionFactor).mul(stepRatioScale);\n  var formatStep = amendStepRatio.mul(digitCountValue);\n  return allowDecimals ? formatStep : new Decimal(Math.ceil(formatStep));\n}\n/**\n * calculate the ticks when the minimum value equals to the maximum value\n *\n * @param  {Number}  value         The minimum valuue which is also the maximum value\n * @param  {Integer} tickCount     The count of ticks\n * @param  {Boolean} allowDecimals Allow the ticks to be decimals or not\n * @return {Array}                 ticks\n */\n\n\nfunction getTickOfSingleValue(value, tickCount, allowDecimals) {\n  var step = 1; // calculate the middle value of ticks\n\n  var middle = new Decimal(value);\n\n  if (!middle.isint() && allowDecimals) {\n    var absVal = Math.abs(value);\n\n    if (absVal < 1) {\n      // The step should be a float number when the difference is smaller than 1\n      step = new Decimal(10).pow(Arithmetic.getDigitCount(value) - 1);\n      middle = new Decimal(Math.floor(middle.div(step).toNumber())).mul(step);\n    } else if (absVal > 1) {\n      // Return the maximum integer which is smaller than 'value' when 'value' is greater than 1\n      middle = new Decimal(Math.floor(value));\n    }\n  } else if (value === 0) {\n    middle = new Decimal(Math.floor((tickCount - 1) / 2));\n  } else if (!allowDecimals) {\n    middle = new Decimal(Math.floor(value));\n  }\n\n  var middleIndex = Math.floor((tickCount - 1) / 2);\n  var fn = compose(map(function (n) {\n    return middle.add(new Decimal(n - middleIndex).mul(step)).toNumber();\n  }), range);\n  return fn(0, tickCount);\n}\n/**\n * Calculate the step\n *\n * @param  {Number}  min              The minimum value of an interval\n * @param  {Number}  max              The maximum value of an interval\n * @param  {Integer} tickCount        The count of ticks\n * @param  {Boolean} allowDecimals    Allow the ticks to be decimals or not\n * @param  {Number}  correctionFactor A correction factor\n * @return {Object}  The step, minimum value of ticks, maximum value of ticks\n */\n\n\nfunction calculateStep(min, max, tickCount, allowDecimals) {\n  var correctionFactor = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0;\n\n  // dirty hack (for recharts' test)\n  if (!Number.isFinite((max - min) / (tickCount - 1))) {\n    return {\n      step: new Decimal(0),\n      tickMin: new Decimal(0),\n      tickMax: new Decimal(0)\n    };\n  } // The step which is easy to understand between two ticks\n\n\n  var step = getFormatStep(new Decimal(max).sub(min).div(tickCount - 1), allowDecimals, correctionFactor); // A medial value of ticks\n\n  var middle; // When 0 is inside the interval, 0 should be a tick\n\n  if (min <= 0 && max >= 0) {\n    middle = new Decimal(0);\n  } else {\n    // calculate the middle value\n    middle = new Decimal(min).add(max).div(2); // minus modulo value\n\n    middle = middle.sub(new Decimal(middle).mod(step));\n  }\n\n  var belowCount = Math.ceil(middle.sub(min).div(step).toNumber());\n  var upCount = Math.ceil(new Decimal(max).sub(middle).div(step).toNumber());\n  var scaleCount = belowCount + upCount + 1;\n\n  if (scaleCount > tickCount) {\n    // When more ticks need to cover the interval, step should be bigger.\n    return calculateStep(min, max, tickCount, allowDecimals, correctionFactor + 1);\n  }\n\n  if (scaleCount < tickCount) {\n    // When less ticks can cover the interval, we should add some additional ticks\n    upCount = max > 0 ? upCount + (tickCount - scaleCount) : upCount;\n    belowCount = max > 0 ? belowCount : belowCount + (tickCount - scaleCount);\n  }\n\n  return {\n    step: step,\n    tickMin: middle.sub(new Decimal(belowCount).mul(step)),\n    tickMax: middle.add(new Decimal(upCount).mul(step))\n  };\n}\n/**\n * Calculate the ticks of an interval, the count of ticks will be guraranteed\n *\n * @param  {Number}  min, max      min: The minimum value, max: The maximum value\n * @param  {Integer} tickCount     The count of ticks\n * @param  {Boolean} allowDecimals Allow the ticks to be decimals or not\n * @return {Array}   ticks\n */\n\n\nfunction getNiceTickValuesFn(_ref3) {\n  var _ref4 = _slicedToArray(_ref3, 2),\n      min = _ref4[0],\n      max = _ref4[1];\n\n  var tickCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  // More than two ticks should be return\n  var count = Math.max(tickCount, 2);\n\n  var _getValidInterval = getValidInterval([min, max]),\n      _getValidInterval2 = _slicedToArray(_getValidInterval, 2),\n      cormin = _getValidInterval2[0],\n      cormax = _getValidInterval2[1];\n\n  if (cormin === -Infinity || cormax === Infinity) {\n    var _values = cormax === Infinity ? [cormin].concat(_toConsumableArray(range(0, tickCount - 1).map(function () {\n      return Infinity;\n    }))) : [].concat(_toConsumableArray(range(0, tickCount - 1).map(function () {\n      return -Infinity;\n    })), [cormax]);\n\n    return min > max ? reverse(_values) : _values;\n  }\n\n  if (cormin === cormax) {\n    return getTickOfSingleValue(cormin, tickCount, allowDecimals);\n  } // Get the step between two ticks\n\n\n  var _calculateStep = calculateStep(cormin, cormax, count, allowDecimals),\n      step = _calculateStep.step,\n      tickMin = _calculateStep.tickMin,\n      tickMax = _calculateStep.tickMax;\n\n  var values = Arithmetic.rangeStep(tickMin, tickMax.add(new Decimal(0.1).mul(step)), step);\n  return min > max ? reverse(values) : values;\n}\n/**\n * Calculate the ticks of an interval, the count of ticks won't be guraranteed\n *\n * @param  {Number}  min, max      min: The minimum value, max: The maximum value\n * @param  {Integer} tickCount     The count of ticks\n * @param  {Boolean} allowDecimals Allow the ticks to be decimals or not\n * @return {Array}   ticks\n */\n\n\nfunction getTickValuesFn(_ref5) {\n  var _ref6 = _slicedToArray(_ref5, 2),\n      min = _ref6[0],\n      max = _ref6[1];\n\n  var tickCount = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 6;\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n  // More than two ticks should be return\n  var count = Math.max(tickCount, 2);\n\n  var _getValidInterval3 = getValidInterval([min, max]),\n      _getValidInterval4 = _slicedToArray(_getValidInterval3, 2),\n      cormin = _getValidInterval4[0],\n      cormax = _getValidInterval4[1];\n\n  if (cormin === -Infinity || cormax === Infinity) {\n    return [min, max];\n  }\n\n  if (cormin === cormax) {\n    return getTickOfSingleValue(cormin, tickCount, allowDecimals);\n  }\n\n  var step = getFormatStep(new Decimal(cormax).sub(cormin).div(count - 1), allowDecimals, 0);\n  var fn = compose(map(function (n) {\n    return new Decimal(cormin).add(new Decimal(n).mul(step)).toNumber();\n  }), range);\n  var values = fn(0, count).filter(function (entry) {\n    return entry >= cormin && entry <= cormax;\n  });\n  return min > max ? reverse(values) : values;\n}\n/**\n * Calculate the ticks of an interval, the count of ticks won't be guraranteed,\n * but the domain will be guaranteed\n *\n * @param  {Number}  min, max      min: The minimum value, max: The maximum value\n * @param  {Integer} tickCount     The count of ticks\n * @param  {Boolean} allowDecimals Allow the ticks to be decimals or not\n * @return {Array}   ticks\n */\n\n\nfunction getTickValuesFixedDomainFn(_ref7, tickCount) {\n  var _ref8 = _slicedToArray(_ref7, 2),\n      min = _ref8[0],\n      max = _ref8[1];\n\n  var allowDecimals = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  // More than two ticks should be return\n  var _getValidInterval5 = getValidInterval([min, max]),\n      _getValidInterval6 = _slicedToArray(_getValidInterval5, 2),\n      cormin = _getValidInterval6[0],\n      cormax = _getValidInterval6[1];\n\n  if (cormin === -Infinity || cormax === Infinity) {\n    return [min, max];\n  }\n\n  if (cormin === cormax) {\n    return [cormin];\n  }\n\n  var count = Math.max(tickCount, 2);\n  var step = getFormatStep(new Decimal(cormax).sub(cormin).div(count - 1), allowDecimals, 0);\n  var values = [].concat(_toConsumableArray(Arithmetic.rangeStep(new Decimal(cormin), new Decimal(cormax).sub(new Decimal(0.99).mul(step)), step)), [cormax]);\n  return min > max ? reverse(values) : values;\n}\n\nexport var getNiceTickValues = memoize(getNiceTickValuesFn);\nexport var getTickValues = memoize(getTickValuesFn);\nexport var getTickValuesFixedDomain = memoize(getTickValuesFixedDomainFn);"],"mappings":"AAAA,SAASA,kBAAT,CAA4BC,GAA5B,EAAiC;EAAE,OAAOC,kBAAkB,CAACD,GAAD,CAAlB,IAA2BE,gBAAgB,CAACF,GAAD,CAA3C,IAAoDG,2BAA2B,CAACH,GAAD,CAA/E,IAAwFI,kBAAkB,EAAjH;AAAsH;;AAEzJ,SAASA,kBAAT,GAA8B;EAAE,MAAM,IAAIC,SAAJ,CAAc,sIAAd,CAAN;AAA8J;;AAE9L,SAASH,gBAAT,CAA0BI,IAA1B,EAAgC;EAAE,IAAI,OAAOC,MAAP,KAAkB,WAAlB,IAAiCA,MAAM,CAACC,QAAP,IAAmBC,MAAM,CAACH,IAAD,CAA9D,EAAsE,OAAOI,KAAK,CAACC,IAAN,CAAWL,IAAX,CAAP;AAA0B;;AAElI,SAASL,kBAAT,CAA4BD,GAA5B,EAAiC;EAAE,IAAIU,KAAK,CAACE,OAAN,CAAcZ,GAAd,CAAJ,EAAwB,OAAOa,iBAAiB,CAACb,GAAD,CAAxB;AAAgC;;AAE3F,SAASc,cAAT,CAAwBd,GAAxB,EAA6Be,CAA7B,EAAgC;EAAE,OAAOC,eAAe,CAAChB,GAAD,CAAf,IAAwBiB,qBAAqB,CAACjB,GAAD,EAAMe,CAAN,CAA7C,IAAyDZ,2BAA2B,CAACH,GAAD,EAAMe,CAAN,CAApF,IAAgGG,gBAAgB,EAAvH;AAA4H;;AAE9J,SAASA,gBAAT,GAA4B;EAAE,MAAM,IAAIb,SAAJ,CAAc,2IAAd,CAAN;AAAmK;;AAEjM,SAASF,2BAAT,CAAqCgB,CAArC,EAAwCC,MAAxC,EAAgD;EAAE,IAAI,CAACD,CAAL,EAAQ;EAAQ,IAAI,OAAOA,CAAP,KAAa,QAAjB,EAA2B,OAAON,iBAAiB,CAACM,CAAD,EAAIC,MAAJ,CAAxB;EAAqC,IAAIC,CAAC,GAAGZ,MAAM,CAACa,SAAP,CAAiBC,QAAjB,CAA0BC,IAA1B,CAA+BL,CAA/B,EAAkCM,KAAlC,CAAwC,CAAxC,EAA2C,CAAC,CAA5C,CAAR;EAAwD,IAAIJ,CAAC,KAAK,QAAN,IAAkBF,CAAC,CAACO,WAAxB,EAAqCL,CAAC,GAAGF,CAAC,CAACO,WAAF,CAAcC,IAAlB;EAAwB,IAAIN,CAAC,KAAK,KAAN,IAAeA,CAAC,KAAK,KAAzB,EAAgC,OAAOX,KAAK,CAACC,IAAN,CAAWQ,CAAX,CAAP;EAAsB,IAAIE,CAAC,KAAK,WAAN,IAAqB,2CAA2CO,IAA3C,CAAgDP,CAAhD,CAAzB,EAA6E,OAAOR,iBAAiB,CAACM,CAAD,EAAIC,MAAJ,CAAxB;AAAsC;;AAEha,SAASP,iBAAT,CAA2Bb,GAA3B,EAAgC6B,GAAhC,EAAqC;EAAE,IAAIA,GAAG,IAAI,IAAP,IAAeA,GAAG,GAAG7B,GAAG,CAAC8B,MAA7B,EAAqCD,GAAG,GAAG7B,GAAG,CAAC8B,MAAV;;EAAkB,KAAK,IAAIf,CAAC,GAAG,CAAR,EAAWgB,IAAI,GAAG,IAAIrB,KAAJ,CAAUmB,GAAV,CAAvB,EAAuCd,CAAC,GAAGc,GAA3C,EAAgDd,CAAC,EAAjD,EAAqD;IAAEgB,IAAI,CAAChB,CAAD,CAAJ,GAAUf,GAAG,CAACe,CAAD,CAAb;EAAmB;;EAAC,OAAOgB,IAAP;AAAc;;AAEvL,SAASd,qBAAT,CAA+BjB,GAA/B,EAAoCe,CAApC,EAAuC;EAAE,IAAI,OAAOR,MAAP,KAAkB,WAAlB,IAAiC,EAAEA,MAAM,CAACC,QAAP,IAAmBC,MAAM,CAACT,GAAD,CAA3B,CAArC,EAAwE;EAAQ,IAAIgC,IAAI,GAAG,EAAX;EAAe,IAAIC,EAAE,GAAG,IAAT;EAAe,IAAIC,EAAE,GAAG,KAAT;EAAgB,IAAIC,EAAE,GAAGC,SAAT;;EAAoB,IAAI;IAAE,KAAK,IAAIC,EAAE,GAAGrC,GAAG,CAACO,MAAM,CAACC,QAAR,CAAH,EAAT,EAAiC8B,EAAtC,EAA0C,EAAEL,EAAE,GAAG,CAACK,EAAE,GAAGD,EAAE,CAACE,IAAH,EAAN,EAAiBC,IAAxB,CAA1C,EAAyEP,EAAE,GAAG,IAA9E,EAAoF;MAAED,IAAI,CAACS,IAAL,CAAUH,EAAE,CAACI,KAAb;;MAAqB,IAAI3B,CAAC,IAAIiB,IAAI,CAACF,MAAL,KAAgBf,CAAzB,EAA4B;IAAQ;EAAE,CAAvJ,CAAwJ,OAAO4B,GAAP,EAAY;IAAET,EAAE,GAAG,IAAL;IAAWC,EAAE,GAAGQ,GAAL;EAAW,CAA5L,SAAqM;IAAE,IAAI;MAAE,IAAI,CAACV,EAAD,IAAOI,EAAE,CAAC,QAAD,CAAF,IAAgB,IAA3B,EAAiCA,EAAE,CAAC,QAAD,CAAF;IAAiB,CAAxD,SAAiE;MAAE,IAAIH,EAAJ,EAAQ,MAAMC,EAAN;IAAW;EAAE;;EAAC,OAAOH,IAAP;AAAc;;AAEze,SAAShB,eAAT,CAAyBhB,GAAzB,EAA8B;EAAE,IAAIU,KAAK,CAACE,OAAN,CAAcZ,GAAd,CAAJ,EAAwB,OAAOA,GAAP;AAAa;AAErE;AACA;AACA;AACA;AACA;;;AACA,OAAO4C,OAAP,MAAoB,kBAApB;AACA,SAASC,OAAT,EAAkBC,KAAlB,EAAyBC,OAAzB,EAAkCC,GAAlC,EAAuCC,OAAvC,QAAsD,cAAtD;AACA,OAAOC,UAAP,MAAuB,mBAAvB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,SAASC,gBAAT,CAA0BC,IAA1B,EAAgC;EAC9B,IAAIC,KAAK,GAAGvC,cAAc,CAACsC,IAAD,EAAO,CAAP,CAA1B;EAAA,IACIE,GAAG,GAAGD,KAAK,CAAC,CAAD,CADf;EAAA,IAEIE,GAAG,GAAGF,KAAK,CAAC,CAAD,CAFf;;EAIA,IAAIG,QAAQ,GAAGF,GAAf;EAAA,IACIG,QAAQ,GAAGF,GADf,CAL8B,CAMV;;EAEpB,IAAID,GAAG,GAAGC,GAAV,EAAe;IACbC,QAAQ,GAAGD,GAAX;IACAE,QAAQ,GAAGH,GAAX;EACD;;EAED,OAAO,CAACE,QAAD,EAAWC,QAAX,CAAP;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASC,aAAT,CAAuBC,SAAvB,EAAkCC,aAAlC,EAAiDC,gBAAjD,EAAmE;EACjE,IAAIF,SAAS,CAACG,GAAV,CAAc,CAAd,CAAJ,EAAsB;IACpB,OAAO,IAAIlB,OAAJ,CAAY,CAAZ,CAAP;EACD;;EAED,IAAImB,UAAU,GAAGb,UAAU,CAACc,aAAX,CAAyBL,SAAS,CAACM,QAAV,EAAzB,CAAjB,CALiE,CAKA;EACjE;;EAEA,IAAIC,eAAe,GAAG,IAAItB,OAAJ,CAAY,EAAZ,EAAgBuB,GAAhB,CAAoBJ,UAApB,CAAtB;EACA,IAAIK,SAAS,GAAGT,SAAS,CAACU,GAAV,CAAcH,eAAd,CAAhB,CATiE,CASjB;;EAEhD,IAAII,cAAc,GAAGP,UAAU,KAAK,CAAf,GAAmB,IAAnB,GAA0B,GAA/C;EACA,IAAIQ,cAAc,GAAG,IAAI3B,OAAJ,CAAY4B,IAAI,CAACC,IAAL,CAAUL,SAAS,CAACC,GAAV,CAAcC,cAAd,EAA8BL,QAA9B,EAAV,CAAZ,EAAiES,GAAjE,CAAqEb,gBAArE,EAAuFc,GAAvF,CAA2FL,cAA3F,CAArB;EACA,IAAIM,UAAU,GAAGL,cAAc,CAACI,GAAf,CAAmBT,eAAnB,CAAjB;EACA,OAAON,aAAa,GAAGgB,UAAH,GAAgB,IAAIhC,OAAJ,CAAY4B,IAAI,CAACC,IAAL,CAAUG,UAAV,CAAZ,CAApC;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASC,oBAAT,CAA8BnC,KAA9B,EAAqCoC,SAArC,EAAgDlB,aAAhD,EAA+D;EAC7D,IAAImB,IAAI,GAAG,CAAX,CAD6D,CAC/C;;EAEd,IAAIC,MAAM,GAAG,IAAIpC,OAAJ,CAAYF,KAAZ,CAAb;;EAEA,IAAI,CAACsC,MAAM,CAACC,KAAP,EAAD,IAAmBrB,aAAvB,EAAsC;IACpC,IAAIsB,MAAM,GAAGV,IAAI,CAACW,GAAL,CAASzC,KAAT,CAAb;;IAEA,IAAIwC,MAAM,GAAG,CAAb,EAAgB;MACd;MACAH,IAAI,GAAG,IAAInC,OAAJ,CAAY,EAAZ,EAAgBuB,GAAhB,CAAoBjB,UAAU,CAACc,aAAX,CAAyBtB,KAAzB,IAAkC,CAAtD,CAAP;MACAsC,MAAM,GAAG,IAAIpC,OAAJ,CAAY4B,IAAI,CAACY,KAAL,CAAWJ,MAAM,CAACX,GAAP,CAAWU,IAAX,EAAiBd,QAAjB,EAAX,CAAZ,EAAqDU,GAArD,CAAyDI,IAAzD,CAAT;IACD,CAJD,MAIO,IAAIG,MAAM,GAAG,CAAb,EAAgB;MACrB;MACAF,MAAM,GAAG,IAAIpC,OAAJ,CAAY4B,IAAI,CAACY,KAAL,CAAW1C,KAAX,CAAZ,CAAT;IACD;EACF,CAXD,MAWO,IAAIA,KAAK,KAAK,CAAd,EAAiB;IACtBsC,MAAM,GAAG,IAAIpC,OAAJ,CAAY4B,IAAI,CAACY,KAAL,CAAW,CAACN,SAAS,GAAG,CAAb,IAAkB,CAA7B,CAAZ,CAAT;EACD,CAFM,MAEA,IAAI,CAAClB,aAAL,EAAoB;IACzBoB,MAAM,GAAG,IAAIpC,OAAJ,CAAY4B,IAAI,CAACY,KAAL,CAAW1C,KAAX,CAAZ,CAAT;EACD;;EAED,IAAI2C,WAAW,GAAGb,IAAI,CAACY,KAAL,CAAW,CAACN,SAAS,GAAG,CAAb,IAAkB,CAA7B,CAAlB;EACA,IAAIQ,EAAE,GAAGzC,OAAO,CAACG,GAAG,CAAC,UAAU3B,CAAV,EAAa;IAChC,OAAO2D,MAAM,CAACN,GAAP,CAAW,IAAI9B,OAAJ,CAAYvB,CAAC,GAAGgE,WAAhB,EAA6BV,GAA7B,CAAiCI,IAAjC,CAAX,EAAmDd,QAAnD,EAAP;EACD,CAFmB,CAAJ,EAEZnB,KAFY,CAAhB;EAGA,OAAOwC,EAAE,CAAC,CAAD,EAAIR,SAAJ,CAAT;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASS,aAAT,CAAuBjC,GAAvB,EAA4BC,GAA5B,EAAiCuB,SAAjC,EAA4ClB,aAA5C,EAA2D;EACzD,IAAIC,gBAAgB,GAAG2B,SAAS,CAAC1D,MAAV,GAAmB,CAAnB,IAAwB0D,SAAS,CAAC,CAAD,CAAT,KAAiBpD,SAAzC,GAAqDoD,SAAS,CAAC,CAAD,CAA9D,GAAoE,CAA3F,CADyD,CAGzD;;EACA,IAAI,CAACC,MAAM,CAACC,QAAP,CAAgB,CAACnC,GAAG,GAAGD,GAAP,KAAewB,SAAS,GAAG,CAA3B,CAAhB,CAAL,EAAqD;IACnD,OAAO;MACLC,IAAI,EAAE,IAAInC,OAAJ,CAAY,CAAZ,CADD;MAEL+C,OAAO,EAAE,IAAI/C,OAAJ,CAAY,CAAZ,CAFJ;MAGLgD,OAAO,EAAE,IAAIhD,OAAJ,CAAY,CAAZ;IAHJ,CAAP;EAKD,CAVwD,CAUvD;;;EAGF,IAAImC,IAAI,GAAGrB,aAAa,CAAC,IAAId,OAAJ,CAAYW,GAAZ,EAAiBsC,GAAjB,CAAqBvC,GAArB,EAA0Be,GAA1B,CAA8BS,SAAS,GAAG,CAA1C,CAAD,EAA+ClB,aAA/C,EAA8DC,gBAA9D,CAAxB,CAbyD,CAagD;;EAEzG,IAAImB,MAAJ,CAfyD,CAe7C;;EAEZ,IAAI1B,GAAG,IAAI,CAAP,IAAYC,GAAG,IAAI,CAAvB,EAA0B;IACxByB,MAAM,GAAG,IAAIpC,OAAJ,CAAY,CAAZ,CAAT;EACD,CAFD,MAEO;IACL;IACAoC,MAAM,GAAG,IAAIpC,OAAJ,CAAYU,GAAZ,EAAiBoB,GAAjB,CAAqBnB,GAArB,EAA0Bc,GAA1B,CAA8B,CAA9B,CAAT,CAFK,CAEsC;;IAE3CW,MAAM,GAAGA,MAAM,CAACa,GAAP,CAAW,IAAIjD,OAAJ,CAAYoC,MAAZ,EAAoBc,GAApB,CAAwBf,IAAxB,CAAX,CAAT;EACD;;EAED,IAAIgB,UAAU,GAAGvB,IAAI,CAACC,IAAL,CAAUO,MAAM,CAACa,GAAP,CAAWvC,GAAX,EAAgBe,GAAhB,CAAoBU,IAApB,EAA0Bd,QAA1B,EAAV,CAAjB;EACA,IAAI+B,OAAO,GAAGxB,IAAI,CAACC,IAAL,CAAU,IAAI7B,OAAJ,CAAYW,GAAZ,EAAiBsC,GAAjB,CAAqBb,MAArB,EAA6BX,GAA7B,CAAiCU,IAAjC,EAAuCd,QAAvC,EAAV,CAAd;EACA,IAAIgC,UAAU,GAAGF,UAAU,GAAGC,OAAb,GAAuB,CAAxC;;EAEA,IAAIC,UAAU,GAAGnB,SAAjB,EAA4B;IAC1B;IACA,OAAOS,aAAa,CAACjC,GAAD,EAAMC,GAAN,EAAWuB,SAAX,EAAsBlB,aAAtB,EAAqCC,gBAAgB,GAAG,CAAxD,CAApB;EACD;;EAED,IAAIoC,UAAU,GAAGnB,SAAjB,EAA4B;IAC1B;IACAkB,OAAO,GAAGzC,GAAG,GAAG,CAAN,GAAUyC,OAAO,IAAIlB,SAAS,GAAGmB,UAAhB,CAAjB,GAA+CD,OAAzD;IACAD,UAAU,GAAGxC,GAAG,GAAG,CAAN,GAAUwC,UAAV,GAAuBA,UAAU,IAAIjB,SAAS,GAAGmB,UAAhB,CAA9C;EACD;;EAED,OAAO;IACLlB,IAAI,EAAEA,IADD;IAELY,OAAO,EAAEX,MAAM,CAACa,GAAP,CAAW,IAAIjD,OAAJ,CAAYmD,UAAZ,EAAwBpB,GAAxB,CAA4BI,IAA5B,CAAX,CAFJ;IAGLa,OAAO,EAAEZ,MAAM,CAACN,GAAP,CAAW,IAAI9B,OAAJ,CAAYoD,OAAZ,EAAqBrB,GAArB,CAAyBI,IAAzB,CAAX;EAHJ,CAAP;AAKD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASmB,mBAAT,CAA6BC,KAA7B,EAAoC;EAClC,IAAIC,KAAK,GAAGtF,cAAc,CAACqF,KAAD,EAAQ,CAAR,CAA1B;EAAA,IACI7C,GAAG,GAAG8C,KAAK,CAAC,CAAD,CADf;EAAA,IAEI7C,GAAG,GAAG6C,KAAK,CAAC,CAAD,CAFf;;EAIA,IAAItB,SAAS,GAAGU,SAAS,CAAC1D,MAAV,GAAmB,CAAnB,IAAwB0D,SAAS,CAAC,CAAD,CAAT,KAAiBpD,SAAzC,GAAqDoD,SAAS,CAAC,CAAD,CAA9D,GAAoE,CAApF;EACA,IAAI5B,aAAa,GAAG4B,SAAS,CAAC1D,MAAV,GAAmB,CAAnB,IAAwB0D,SAAS,CAAC,CAAD,CAAT,KAAiBpD,SAAzC,GAAqDoD,SAAS,CAAC,CAAD,CAA9D,GAAoE,IAAxF,CANkC,CAOlC;;EACA,IAAIa,KAAK,GAAG7B,IAAI,CAACjB,GAAL,CAASuB,SAAT,EAAoB,CAApB,CAAZ;;EAEA,IAAIwB,iBAAiB,GAAGnD,gBAAgB,CAAC,CAACG,GAAD,EAAMC,GAAN,CAAD,CAAxC;EAAA,IACIgD,kBAAkB,GAAGzF,cAAc,CAACwF,iBAAD,EAAoB,CAApB,CADvC;EAAA,IAEIE,MAAM,GAAGD,kBAAkB,CAAC,CAAD,CAF/B;EAAA,IAGIE,MAAM,GAAGF,kBAAkB,CAAC,CAAD,CAH/B;;EAKA,IAAIC,MAAM,KAAK,CAACE,QAAZ,IAAwBD,MAAM,KAAKC,QAAvC,EAAiD;IAC/C,IAAIC,OAAO,GAAGF,MAAM,KAAKC,QAAX,GAAsB,CAACF,MAAD,EAASI,MAAT,CAAgB7G,kBAAkB,CAAC+C,KAAK,CAAC,CAAD,EAAIgC,SAAS,GAAG,CAAhB,CAAL,CAAwB9B,GAAxB,CAA4B,YAAY;MAC7G,OAAO0D,QAAP;IACD,CAFsE,CAAD,CAAlC,CAAtB,GAEP,GAAGE,MAAH,CAAU7G,kBAAkB,CAAC+C,KAAK,CAAC,CAAD,EAAIgC,SAAS,GAAG,CAAhB,CAAL,CAAwB9B,GAAxB,CAA4B,YAAY;MAC1E,OAAO,CAAC0D,QAAR;IACD,CAFmC,CAAD,CAA5B,EAEF,CAACD,MAAD,CAFE,CAFP;;IAMA,OAAOnD,GAAG,GAAGC,GAAN,GAAYN,OAAO,CAAC0D,OAAD,CAAnB,GAA+BA,OAAtC;EACD;;EAED,IAAIH,MAAM,KAAKC,MAAf,EAAuB;IACrB,OAAO5B,oBAAoB,CAAC2B,MAAD,EAAS1B,SAAT,EAAoBlB,aAApB,CAA3B;EACD,CA3BiC,CA2BhC;;;EAGF,IAAIiD,cAAc,GAAGtB,aAAa,CAACiB,MAAD,EAASC,MAAT,EAAiBJ,KAAjB,EAAwBzC,aAAxB,CAAlC;EAAA,IACImB,IAAI,GAAG8B,cAAc,CAAC9B,IAD1B;EAAA,IAEIY,OAAO,GAAGkB,cAAc,CAAClB,OAF7B;EAAA,IAGIC,OAAO,GAAGiB,cAAc,CAACjB,OAH7B;;EAKA,IAAIkB,MAAM,GAAG5D,UAAU,CAAC6D,SAAX,CAAqBpB,OAArB,EAA8BC,OAAO,CAAClB,GAAR,CAAY,IAAI9B,OAAJ,CAAY,GAAZ,EAAiB+B,GAAjB,CAAqBI,IAArB,CAAZ,CAA9B,EAAuEA,IAAvE,CAAb;EACA,OAAOzB,GAAG,GAAGC,GAAN,GAAYN,OAAO,CAAC6D,MAAD,CAAnB,GAA8BA,MAArC;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASE,eAAT,CAAyBC,KAAzB,EAAgC;EAC9B,IAAIC,KAAK,GAAGpG,cAAc,CAACmG,KAAD,EAAQ,CAAR,CAA1B;EAAA,IACI3D,GAAG,GAAG4D,KAAK,CAAC,CAAD,CADf;EAAA,IAEI3D,GAAG,GAAG2D,KAAK,CAAC,CAAD,CAFf;;EAIA,IAAIpC,SAAS,GAAGU,SAAS,CAAC1D,MAAV,GAAmB,CAAnB,IAAwB0D,SAAS,CAAC,CAAD,CAAT,KAAiBpD,SAAzC,GAAqDoD,SAAS,CAAC,CAAD,CAA9D,GAAoE,CAApF;EACA,IAAI5B,aAAa,GAAG4B,SAAS,CAAC1D,MAAV,GAAmB,CAAnB,IAAwB0D,SAAS,CAAC,CAAD,CAAT,KAAiBpD,SAAzC,GAAqDoD,SAAS,CAAC,CAAD,CAA9D,GAAoE,IAAxF,CAN8B,CAO9B;;EACA,IAAIa,KAAK,GAAG7B,IAAI,CAACjB,GAAL,CAASuB,SAAT,EAAoB,CAApB,CAAZ;;EAEA,IAAIqC,kBAAkB,GAAGhE,gBAAgB,CAAC,CAACG,GAAD,EAAMC,GAAN,CAAD,CAAzC;EAAA,IACI6D,kBAAkB,GAAGtG,cAAc,CAACqG,kBAAD,EAAqB,CAArB,CADvC;EAAA,IAEIX,MAAM,GAAGY,kBAAkB,CAAC,CAAD,CAF/B;EAAA,IAGIX,MAAM,GAAGW,kBAAkB,CAAC,CAAD,CAH/B;;EAKA,IAAIZ,MAAM,KAAK,CAACE,QAAZ,IAAwBD,MAAM,KAAKC,QAAvC,EAAiD;IAC/C,OAAO,CAACpD,GAAD,EAAMC,GAAN,CAAP;EACD;;EAED,IAAIiD,MAAM,KAAKC,MAAf,EAAuB;IACrB,OAAO5B,oBAAoB,CAAC2B,MAAD,EAAS1B,SAAT,EAAoBlB,aAApB,CAA3B;EACD;;EAED,IAAImB,IAAI,GAAGrB,aAAa,CAAC,IAAId,OAAJ,CAAY6D,MAAZ,EAAoBZ,GAApB,CAAwBW,MAAxB,EAAgCnC,GAAhC,CAAoCgC,KAAK,GAAG,CAA5C,CAAD,EAAiDzC,aAAjD,EAAgE,CAAhE,CAAxB;EACA,IAAI0B,EAAE,GAAGzC,OAAO,CAACG,GAAG,CAAC,UAAU3B,CAAV,EAAa;IAChC,OAAO,IAAIuB,OAAJ,CAAY4D,MAAZ,EAAoB9B,GAApB,CAAwB,IAAI9B,OAAJ,CAAYvB,CAAZ,EAAesD,GAAf,CAAmBI,IAAnB,CAAxB,EAAkDd,QAAlD,EAAP;EACD,CAFmB,CAAJ,EAEZnB,KAFY,CAAhB;EAGA,IAAIgE,MAAM,GAAGxB,EAAE,CAAC,CAAD,EAAIe,KAAJ,CAAF,CAAagB,MAAb,CAAoB,UAAUC,KAAV,EAAiB;IAChD,OAAOA,KAAK,IAAId,MAAT,IAAmBc,KAAK,IAAIb,MAAnC;EACD,CAFY,CAAb;EAGA,OAAOnD,GAAG,GAAGC,GAAN,GAAYN,OAAO,CAAC6D,MAAD,CAAnB,GAA8BA,MAArC;AACD;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA,SAASS,0BAAT,CAAoCC,KAApC,EAA2C1C,SAA3C,EAAsD;EACpD,IAAI2C,KAAK,GAAG3G,cAAc,CAAC0G,KAAD,EAAQ,CAAR,CAA1B;EAAA,IACIlE,GAAG,GAAGmE,KAAK,CAAC,CAAD,CADf;EAAA,IAEIlE,GAAG,GAAGkE,KAAK,CAAC,CAAD,CAFf;;EAIA,IAAI7D,aAAa,GAAG4B,SAAS,CAAC1D,MAAV,GAAmB,CAAnB,IAAwB0D,SAAS,CAAC,CAAD,CAAT,KAAiBpD,SAAzC,GAAqDoD,SAAS,CAAC,CAAD,CAA9D,GAAoE,IAAxF,CALoD,CAOpD;;EACA,IAAIkC,kBAAkB,GAAGvE,gBAAgB,CAAC,CAACG,GAAD,EAAMC,GAAN,CAAD,CAAzC;EAAA,IACIoE,kBAAkB,GAAG7G,cAAc,CAAC4G,kBAAD,EAAqB,CAArB,CADvC;EAAA,IAEIlB,MAAM,GAAGmB,kBAAkB,CAAC,CAAD,CAF/B;EAAA,IAGIlB,MAAM,GAAGkB,kBAAkB,CAAC,CAAD,CAH/B;;EAKA,IAAInB,MAAM,KAAK,CAACE,QAAZ,IAAwBD,MAAM,KAAKC,QAAvC,EAAiD;IAC/C,OAAO,CAACpD,GAAD,EAAMC,GAAN,CAAP;EACD;;EAED,IAAIiD,MAAM,KAAKC,MAAf,EAAuB;IACrB,OAAO,CAACD,MAAD,CAAP;EACD;;EAED,IAAIH,KAAK,GAAG7B,IAAI,CAACjB,GAAL,CAASuB,SAAT,EAAoB,CAApB,CAAZ;EACA,IAAIC,IAAI,GAAGrB,aAAa,CAAC,IAAId,OAAJ,CAAY6D,MAAZ,EAAoBZ,GAApB,CAAwBW,MAAxB,EAAgCnC,GAAhC,CAAoCgC,KAAK,GAAG,CAA5C,CAAD,EAAiDzC,aAAjD,EAAgE,CAAhE,CAAxB;EACA,IAAIkD,MAAM,GAAG,GAAGF,MAAH,CAAU7G,kBAAkB,CAACmD,UAAU,CAAC6D,SAAX,CAAqB,IAAInE,OAAJ,CAAY4D,MAAZ,CAArB,EAA0C,IAAI5D,OAAJ,CAAY6D,MAAZ,EAAoBZ,GAApB,CAAwB,IAAIjD,OAAJ,CAAY,IAAZ,EAAkB+B,GAAlB,CAAsBI,IAAtB,CAAxB,CAA1C,EAAgGA,IAAhG,CAAD,CAA5B,EAAqI,CAAC0B,MAAD,CAArI,CAAb;EACA,OAAOnD,GAAG,GAAGC,GAAN,GAAYN,OAAO,CAAC6D,MAAD,CAAnB,GAA8BA,MAArC;AACD;;AAED,OAAO,IAAIc,iBAAiB,GAAG7E,OAAO,CAACmD,mBAAD,CAA/B;AACP,OAAO,IAAI2B,aAAa,GAAG9E,OAAO,CAACiE,eAAD,CAA3B;AACP,OAAO,IAAIc,wBAAwB,GAAG/E,OAAO,CAACwE,0BAAD,CAAtC"},"metadata":{},"sourceType":"module"}